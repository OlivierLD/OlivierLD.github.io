<!--
    Printable and translatable.
    Note in LaTeX:
    $
    \blah
    $
    is left justified,
    $$
    \blah
    $$
    is center justified.

-->
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>M&eacute;thode des moindres carr&eacute;s</title>
    <!--author>Olivier Le Diouris</author-->
    <meta name="author" content="Olivier Le Diouris">
    <link rel="icon" type="image/png" href="./grad.jpg">
    <!--script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script-->
    <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

    <!--link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script-->

    <!--script type="text/javascript"-->
    <!--script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']]
        }
    });
    </script-->

    <script type="text/javascript">
        // That one is OK for the matrixes.
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        },
        "HTML-CSS": {
            availableFonts: ["TeX"] /* ,
            availableFonts: [],
            // Disable preferred fonts to ensure web fonts are used
            preferredFont: null,
            // Force the use of the Neo-Euler web font for rendering math
            webFont: "TeX" // "Neo-Euler" */
        }
    });
    </script>

    <link rel="stylesheet" href="../web.stuff/nse/main.css" />
    <!-- link rel="stylesheet" media="screen" href="main.css" /-->
    <link rel="stylesheet" media="print" href="../web.stuff/nse/print.css" />

    <!--style type="text/css">
        html, body {
            font-size: 1.125rem;
        }
    </style-->
</head>

<section id="fr-content" style="display: none;">
    <h2><a name="least-squares">R&eacute;solution d'une &eacute;quation par la m&eacute;thode des moindres carr&eacute;s</a></h2>
    <span class="screen-only">Traduisible et imprimable</span>
    <a class="screen-only" href="javascript:void(0)" onclick="navTo('EN');"><img src="./images/us_uk_flag.png" style="width: 30px;" title="In English" alt="In English"></a>
    <p>
        <h3>Le probl&egrave;me</h3>
        <p>
            On part d'un <i>nuage de points</i> (quelque chose de n&eacute;buleux), un ensemble de points (x, y) enregistr&eacute;s, qui repr&eacute;sentent une courbe plus ou moins irr&eacute;guli&egrave;re,
            voire compl&egrave;tement cahotique.<br/>
            On cherche &agrave; d&eacute;terminer une courbe lisse, repr&eacute;sent&eacute;e par une &eacute;quation (qui comporte un nombre donn&eacute; de param&egrave;tres), qui soit aussi proche que possible de ce nuage de points.
        </p>
        <h3>L'approche</h3>
        <p>
            Il s'agit donc ici de trouver les coefficients (<span title="AKA: Also Known As,&#13;connu aussi sous le nom de...">aka</span> param&egrave;tres) d'une &eacute;quation, impliquant un nombre donn&eacute; (choisi) de param&egrave;tres, afin que la courbe qui le repr&eacute;sente soit aussi proche que possible d'un ensemble de points donn&eacute;s.<br/>
            Autrement dit, que la courbe trouv&eacute;e colle autant que possible au nuage des points de d&eacute;part.
        </p>
        <table>
            <tr>
                <td style="width: 50%; text-align: center;">
                    <b>Donn&eacute;es initiales : Nuage de points</b><br/>
                    <img src="./images/before.png" alt="Nuage de points" title="Nuage de points" style="max-width: 90%; border: 1px solid silver;"/>
                </td>
                <td style="width: 50%; text-align: center;">
                    <b>Donn&eacute;es finales : Courbe (ici un polyn&ocirc;me de degr&eacute; 4)</b><br/>
                    <img src="./images/after.png" alt="Nuage de points &amp; courbe" title="Nuage de points &amp; courbe" style="max-width: 90%; border: 1px solid silver;"/>
                </td>
            </tr>
        </table>
    </p>
    <hr/>
    <h3>Exemple, illustr&eacute;</h3>
    La m&eacute;thode des moindres carr&eacute;s ne concerne pas que les fonction polyn&ocirc;mes, loin de l&agrave;.<br/>
    On veut ici d&eacute;terminer les coefficients d'une <b>courbe polynomiale</b> du <b>second degr&eacute;</b>, &agrave; partir d'un nuage de points enregistr&eacute;s.<br/>
    On choisit ici un degr&eacute; 2 pour simplifier les &eacute;quations qui suivent.<br/>
    La r&eacute;solution d'un polyn&ocirc;me de degr&eacute; sup&eacute;rieur suivrait le m&ecirc;me mode op&eacute;ratoire.
    <br/><br/>
    On cherche donc &agrave; d&eacute;terminer les coefficients d'un polyn&ocirc;me du 2<sup>nd</sup> degr&eacute;, dont les &eacute;l&eacute;ments sont aussi proches que possible des points d'un ensemble donn&eacute;
    (enregistr&eacute; &agrave; bord d'un bateau, dans le cas qui suit). <br/>
    <br/>
    Les points peuvent &ecirc;tre d&eacute;finis (par leurs coordonn&eacute;s) de diff&eacute;rentes mani&egrave;res, par exemple ici un cap compas (HDC, pour HeaDing Compass) et une route fond (COG, pour Course Over Ground)
    pour d&eacute;terminer une courbe de d&eacute;viation, un angle de vent r&eacute;el et une vitesse du bateau pour d&eacute;terminer des polaires, etc.<br/><br/>
    Pour la commodit&eacute; de la notation, on prendra les points coordonn&eacute;s g&eacute;n&eacute;riquement, comme suit&nbsp;:
    <table>
        <tr>
            <td>
                <div class="postit">
                    $$
                       P^{HDC}_{COG} = P^x_y
                    $$
                </div>
            </td>
            <td>
                , &eacute;crit aussi
            </td>
            <td>
                <div class="postit">
                    $$
                       y = f(x)
                    $$
                </div>
            </td>
            <td>
                o&ugrave;
            </td>
            <td>
                <div class="postit">
                    $$
                       f(x) = ax^2 + bx + c
                    $$
                </div>
            </td>
        </tr>
    </table>
    <!--div class="postit">
    $$
       P^{HDC}_{COG} = P^x_y, ecrit aussi f(x) = y, ou f(x) = ax^2 + bx + c
    $$
    </div-->
    Donc, pour tous les points $(x, y)$ du nuage de donn&eacute;es enregistr&eacute;es, on cherche les coefficients <code>a</code>, <code>b</code>, et <code>c</code> d'un polyn&ocirc;me pour lequel
    <div class="postit">
    $$
    ax^2 + bx + c
    $$
    </div>
    est le plus proche possible de <code>y</code>, c'est &agrave; dire que la diff&eacute;rence
    <div class="postit">
    $$
    ax^2 + bx + c - y
    $$
    </div>
    soit la plus petite possible, donc, que pour tous les points enregistr&eacute;s, le carr&eacute; de cette diff&eacute;rence soit le plus proche possible de z&eacute;ro
    (<i>on &eacute;l&egrave;ve au carr&eacute; pour supprimer le signe</i>, d'o&ugrave; le nom de la m&eacute;thode), et donc que le cumul de ces diff&eacute;rences soit en d&eacute;finitive la plus petite possible. <br/>
    Ceci revient &agrave; calculer les coefficients <code>a</code>, <code>b</code> et <code>c</code> pour lesquels la d&eacute;riv&eacute;e premi&egrave;re de cette sommation des carr&eacute;s des diff&eacute;rences
    par rapport &agrave; chacun des coefficients <code>a</code>, <code>b</code> et <code>c</code> est nulle, ce qui s'&eacute;crit&nbsp;:
    <div class="postit">
    $$ ([\Sigma(ax^2 + bx + c - y)^2])' = 0 $$
    </div>
    <div style="margin: 30px; padding: 5px; border: 1px solid silver; border-radius: 5px;">
        Pour insister : <b>c'est bien ici le c&oelig;ur de la m&eacute;thode.</b><br/>
        <div style="font-style: italic;">
            Pour tous les points du nuage &agrave; r&eacute;soudre, pour chaque <code>x</code>, on calcule la valeur de la fonction (ici polyn&ocirc;me) <code>f(x)</code>, et on veut
            que sa diff&eacute;rence avec <code>y</code> soit la plus petite possible.<br/>
            <u>Donc</u> que la deriv&eacute;e de la fonction de cette diff&eacute;rence (au carr&eacute;, pour supprimer les histoires de signe) soit nulle.
        </div>
    </div>
    <table>
        <tr>
            <td>
                <div class="postit smaller-plus">
                    $$ ([\Sigma(ax^2 + bx + c - y)^2])' = 0 $$
                </div>
            </td>
            <td>s'&eacute;crit aussi</td>
            <td>
                <div class="postit smaller-plus">
                    $$ ([\Sigma((ax^2 + bx + c - y) \times (ax^2 + bx + c - y))])' = 0 $$
                </div>
            </td>
        </tr>
    </table>
    On d&eacute;veloppe la somme avant de d&eacute;river&nbsp;:

    <div class="postit smaller-plus">
    $
    S = a^2\Sigma x^4 + 2ab\Sigma x^3 + 2ac\Sigma x^2 - 2a\Sigma yx^2 + b^2\Sigma x^2 + 2bc\Sigma x - 2b\Sigma yx + c^2\Sigma x^0 - 2c\Sigma y + \Sigma y^2
    $
    </div>
    On d&eacute;rive l'expression ainsi obtenue
    <ul>
        <li>
            Par rapport &agrave; <code>a</code>&nbsp;:
            <div class="postit">
    $ \dfrac{\partial S}{\partial a} = 2a\Sigma x^4 + 2b\Sigma x^3 + 2c\Sigma x^2 - 2\Sigma yx^2 = 0 $
            </div>
        </li>
        <li>
            Par rapport &agrave; <code>b</code>&nbsp;:
            <div class="postit">
    $ \dfrac{\partial S}{\partial b} = 2a\Sigma x^3 + 2b\Sigma x^2 + 2c\Sigma x^1 - 2\Sigma yx^1 = 0 $
            </div>
        </li>
        <li>
            Par rapport &agrave; <code>c</code>&nbsp;:
            <div class="postit">
    $ \dfrac{\partial S}{\partial c} = 2a\Sigma x^2 + 2b\Sigma x^1 + 2c\Sigma x^0 - 2\Sigma yx^0 = 0 $
            </div>
        </li>
    </ul>
    On change les termes en <code>y</code> de c&ocirc;t&eacute;, on simplifie par 2 :
    <ul>
        <li>
            <div class="postit">
    $ a\Sigma x^4 + b\Sigma x^3 + c\Sigma x^2 = \Sigma yx^2 $
            </div>
        </li>
        <li>
            <div class="postit">
    $ a\Sigma x^3 + b\Sigma x^2 + c\Sigma x^1 = \Sigma yx^1 $
            </div>
        </li>
        <li>
            <div class="postit">
    $ a\Sigma x^2 + b\Sigma x^1 + c\Sigma x^0 = \Sigma yx^0 $
            </div>
        </li>
    </ul>

    et on obtient la r&eacute;solution matricielle suivante&nbsp;:
    <div class="postit">
    $ \begin{vmatrix} a & b & c \end{vmatrix} = \begin{vmatrix} \Sigma x^4 & \Sigma x^3 & \Sigma x^2 \\ \Sigma x^3 & \Sigma x^2 & \Sigma x^1 \\ \Sigma x^2 & \Sigma x^1 & \Sigma x^0 \end{vmatrix} ^ {-1} \times \begin{vmatrix} \Sigma yx^2 \\ \Sigma yx^1 \\ \Sigma yx^0 \end{vmatrix} $
    </div>
    <i>Remarques</i>&nbsp;:
    <br/>
    - Les termes $ \Sigma x^0 $ repr&eacute;sentent le nombre de points dans la courbe &agrave; lisser.
    <br/>
    - Un polyn&ocirc;me du 2<sup>nd</sup> degr&eacute; a 3 coefficients, la dimension des matrices qu'on g&egrave;re (carr&eacute;e, ligne, et colonne) est donc 3.
    <p>
    Pour un polyn&ocirc;me de degr&eacute; <code>n</code>, le travail &agrave; effectuer se "r&eacute;sume" ainsi &agrave; inverser la matrice carr&eacute;e $ \Sigma x^{0->2n} $ et de
    la multiplier par la matrice colonne $ \Sigma yx^{0->n} $ pour obtenir la matrice ligne des coefficients du polyn&ocirc;me recherch&eacute;.
    </p>
    <div class="doc-section">
        <h3><a name="least-square-dev">Cas d'une courbe de d&eacute;viation</a></h3>
        <p>
            <hr/>
            <b>Pr&eacute;cision</b> : qu'est-ce que c'est que ce truc ?<br/>
            &Agrave; bord d'un bateau, on a un compas, qui permet de savoir dans quelle direction on se dirige, &eacute;l&eacute;ment essentiel &agrave; la tenue de l'estime.<br/>
            Le "nord vrai" (g&eacute;ographique) est celui des cartes.<br/>
            Le "cap magn&eacute;tique" est celui qui fait intervenir la d&eacute;clinaison magn&eacute;tique locale (qui varie suivant l'endroit o&ugrave; on se trouve sur la plan&egrave;te, et la date).<br/>
            Le "cap compas" est celui indiqu&eacute; par le compas, qui subit les influences magn&eacute;tiques du bateau lui-m&ecirc;me (m&eacute;tal, &eacute;quipements &eacute;lectriques, etc).<br/>
            La d&eacute;viation est la diff&eacute;rence entre le cap compas et le cap magn&eacute;tique.<br/>
            Elle d&eacute;pend <b>du bateau</b>, et de son cap, et est donc une fonction du cap compas lui-m&ecirc;me.<br/>
            Sur un bateau en acier, elle peut atteindre des valeurs &eacute;normes - comme 40 degr&eacute;s - dont il est sans aucun doute de bon ton de tenir compte...
            <hr/>
        </p>
        <p>
            On cherche ici &agrave; &eacute;laborer une courbe de d&eacute;viation, &agrave; partir de points enregistr&eacute;s depuis la station NMEA du bord.
            <br/>
            Dans ce contexte, la station doit comporter un GPS, et un compas (compas &eacute;lectronique, donc). Le GPS permettra &agrave; la station NMEA de g&eacute;n&eacute;rer des cha&icirc;nes RMC - qui vont contenir
            la route fond (Course Over Ground, aka COG), le compas fournira &agrave; la station ce dont elle a besoin pour g&eacute;n&eacute;rer les Caps Compas (Heading, aka HDG, HDM, etc, suivant les stations).
            <br/>
            Le fichier contenant les informations produites par la station NMEA aura ainsi une allure comme celle-ci&nbsp;:
            <pre class="postit">
    . . .
    $IIRMC,190402,A,0854.980,S,14006.028,W,00.0,008,031110,10,E,A*07
    $IIVHW,,,126,M,00.0,N,,*61
    $IIVLW,02839,N,000.0,N*53
    $IIVWR,027,R,07.2,N,,,,*61
    $IIDPT,012.3,+0.7,*40
    $IIGLL,0854.979,S,14006.029,W,190403,A,A*56
    $IIHDG,126,,,10,E*16
    . . .
            </pre>
            On note que le fichier peut contenir d'autres donn&eacute;es (<code>VHW</code>, <code>DPT</code>, <code>GLL</code>, <code>VLW</code>, etc), qu'on ignorera ici.
            <br/>
            Ce fichier sera ensuite travaill&eacute; pour produire un document o&ugrave; ne figureront que les donn&eacute;es qui nous concernent ici, &agrave; savoir la d&eacute;viation en fonction du cap.
            <br/>
            Par exemple (en <span title="JavaScript Object Notation">JSON</span> ici)&nbsp;:
            <pre class="postit">
    [
        { "hdc": 210.000000, "dev": 4.000000 },
        { "hdc": 210.000000, "dev": 4.000000 },
        { "hdc": 210.000000, "dev": -1.000000 },
        { "hdc": 210.000000, "dev": -2.000000 },
        { "hdc": 208.000000, "dev": -4.000000 },
        . . .
    ]
            </pre>
            <div class="screen-only">
                <p>
                    Plus de d&eacute;tails sur ces op&eacute;rations sont disponibles dans d'autres documents&nbsp;:
                    <ul>
                        <li><a href="https://github.com/OlivierLD/ROB/blob/master/raspberry-sailor/Swing/Deviation-Tool/notebooks/LogfileToDeviation.ipynb" target="NB">Jupyter Notebook, en Java</a></li>
                        <li><a href="https://htmlpreview.github.io/?https://github.com/OlivierLD/ROB/blob/master/raspberry-sailor/Swing/Deviation-Tool/README.html" target="dev-curve">Sur le proc&eacute;d&eacute;</a></li>
                        <li><a href="https://github.com/OlivierLD/ROB/tree/master/raspberry-sailor/Swing/Deviation-Tool" target="ROB">Avec des exemples</a></li>
                        <li><a href="/systems/smoothing.spray.html" target="Smoothing-1">Lissage de polyn&ocirc;me, interactif.</a></li>
                    </ul>
                </p>
            </div>
            <br/>
            <br/>
            On consid&egrave;re donc que la forme g&eacute;n&eacute;rique d'une courbe de d&eacute;viation est
            <div class="postit">
            $$
            dev = a + (b \times \cos r) + (c \times \cos r) + (d \times \sin 2r) + (e \times \cos 2r)
            $$
            </div>
            ce qui n'est <i><b>manifestement pas un polyn&ocirc;me</b></i>, mais comme ce sont les coefficients de la formule qu'on cherche,
            la m&eacute;thode des moindres carr&eacute;s peut s'appliquer.
            <br/>
            Dans l'&eacute;quation ci-dessus, <code>r</code> est le Cap Compas, <code>dev</code> est la d&eacute;viation (&delta; entre <code>HDC</code> et <code>HDM</code>, cap compas et cap magn&eacute;tique).<br/>
            On cherche donc &agrave; d&eacute;finir une fonction <code>f</code> pour laquelle la d&eacute;viation <code>dev</code> est obtenue en fournissant <code>r</code>:
            <div class="postit">
                $$ dev = f(r) $$
            </div>
            Gr&acirc;ce au logging, on dispose d'un nuage de points qui comportent chacun au moins les informations suivantes&nbsp;:
            <ul>
                <li>HDC (Heading Compass)</li>
                <li>COG (Course Over Ground)</li>
            </ul>
            Le logging doit s'effectuer sans courant, et sans d&eacute;rive, de fa&ccedil;on &agrave; &ecirc;tre s&ucirc;r que la diff&eacute;rence entre
            le cap compas <code>HDC</code> (corrig&eacute; de la d&eacute;clinaison locale)
            et la route fond (<code>COG</code>) est bien la d&eacute;viation <code>d</code>, que l'on cherche. Pas de d&eacute;rive, pas de courant,
            la route fond est &eacute;gale &agrave; la route surface, qui est &eacute;gale au
            cap vrai du bateau.
            <br/>
            Les &eacute;l&eacute;ments du nuage de points dont on dispose (&eacute;labor&eacute; &agrave; partir du logging) sont d&eacute;finis en
            <div class="postit">
                $$ P_{d}^{HDC} = P_{d}^{r} = P_{y}^{x} $$
            </div>
            En abscisse le Cap Compas, en ordonn&eacute;e la d&eacute;viation.
            <br/>
            On cherche les valeurs de 5 coefficients&nbsp;:
            <div class="postit">
                $ \begin{vmatrix} a & b & c & d & e \end{vmatrix} $
            </div>
            La dimension des matrices &agrave; g&eacute;rer est donc cette fois-ci 5. On applique la m&eacute;thode des moindres carr&eacute;s, d&eacute;crite ci-dessus.
            <br/>
            On obtient les coefficients $ \begin{vmatrix} a & b & c & d & e \end{vmatrix} $ en r&eacute;solvant&nbsp;:
            <div class="postit smaller-plus">
$
  \begin{vmatrix} a & b & c & d & e \end{vmatrix}
                =
  \begin{vmatrix}
  &n  &\sum_{i=0}^{n}\sin(r)  &\sum_{i=0}^{n}\cos(r)  &\sum_{i=0}^{n}\sin(2r)  &\sum_{i=0}^{n}\cos(2r) \\
  &\sum_{i=0}^{n}\sin(r)  &\sum_{i=0}^{n}\sin(r)^2  &\sum_{i=0}^{n}\sin(r)cos(r)  &\sum_{i=0}^{n}\sin(2r)sin(r))  &\sum_{i=0}^{n}\cos(2r)sin(r) \\
  &\sum_{i=0}^{n}\cos(r)  &\sum_{i=0}^{n}\cos(r)sin(r)  &\sum_{i=0}^{n}\cos(r)^2  & \sum_{i=0}^{n}\sin(2r)cos(r) &\sum_{i=0}^{n}\cos(2r)cos(r) \\
  &\sum_{i=0}^{n}\sin(2r)  &\sum_{i=0}^{n}\sin(2r)sin(r)  &\sum_{i=0}^{n}\sin(2r)cos(r)  &\sum_{i=0}^{n}\sin(2r)^2  &\sum_{i=0}^{n}\cos(2r)sin(2r) \\
  &\sum_{i=0}^{n}\cos(2r)  &\sum_{i=0}^{n}\cos(2r)sin(r)  &\sum_{i=0}^{n}\cos(2r)cos(r)  &\sum_{i=0}^{n}\cos(2r)sin(2r)  &\sum_{i=0}^{n}\cos(2r)^2
 \end{vmatrix} ^{-1}

\times

 \begin{vmatrix}
  &\sum_{i=0}^{n}\ dev \\
  &\sum_{i=0}^{n}\ dev.sin(r) \\
  &\sum_{i=0}^{n}\ dev.cos(r) \\
  &\sum_{i=0}^{n}\ dev.sin(2r) \\
  &\sum_{i=0}^{n}\ dev.cos(2r)
 \end{vmatrix}

 $
            </div>
            Fastoche&nbsp;!
            <br>
            <div style="margin-top: 20px;" class="screen-only">
                Pour plus de d&eacute;tails, voir aussi <a href="https://htmlpreview.github.io/?https://github.com/OlivierLD/ROB/blob/master/raspberry-sailor/Swing/Deviation-Tool/README.html" target="dev-curve">ce document</a>,
                et aussi <a href="https://github.com/OlivierLD/ROB/tree/master/raspberry-sailor/Swing/Deviation-Tool" target="ROB">celui-ci</a>, pour un exemple
                complet (incluant le code pour la r&eacute;solution des matrices), partant du fichier de log, passant par le calcul des coefficients, et aboutissant &agrave; l'affichage de la courbe de d&eacute;viation, avec une interface Web.
            </div>
        </p>
    </div>
</section>

<section id="en-content" style="display: none;">
    <h2><a name="least-squares">Solving an Equation Using the Least Squares Method</a></h2>
    <span class="screen-only">Translatable and printable</span>
    <a class="screen-only" href="javascript:void(0)" onclick="navTo('FR');"><img src="./images/france.gif" style="width: 30px;" title="En fran&ccedil;ais" alt="En fran&ccedil;ais"></a>
    <p>
        <h3>The problem</h3>
        <p>
            We start with a <i>point cloud</i> (something nebulous), a set of recorded points (x, y) that represent a more or less irregular, or even completely chaotic, curve.<br/>
            We want to determine a smooth curve, represented by an equation (which has a given number of parameters), that is as close as possible to this point cloud.
        </p>
        <h3>The Approach</h3>
        <p>
            The goal here is to find the coefficients (also known as parameters) of an equation, involving a given (chosen) number of parameters,
            so that the curve representing it is as close as possible to a given set of points.<br/>
            In other words, the resulting curve should fit the initial point cloud as closely as possible.
        </p>
        <table>
            <tr>
                <td style="width: 50%; text-align: center;">
                    <b>Initial Data: Cloud of Points</b><br/>
                    <img src="./images/before.png" alt="Nuage de points" title="Nuage de points" style="max-width: 90%; border: 1px solid silver;"/>
                </td>
                <td style="width: 50%; text-align: center;">
                    <b>Final data: Curve (here a polynomial of degree 4)</b><br/>
                    <img src="./images/after.png" alt="Nuage de points &amp; courbe" title="Nuage de points &amp; courbe" style="max-width: 90%; border: 1px solid silver;"/>
                </td>
            </tr>
        </table>
    </p>
    <hr/>
    <h3>Illustrated Example</h3>
    The least squares method is not limited to polynomial functions, far from it.<br/>
    Here, we want to determine the coefficients of a quadratic polynomial curve from a set of recorded points.<br/>
    We choose a degree 2 polynomial to simplify the following equations.<br/>
    Solving a higher-degree polynomial would follow the same procedure.
    <br/><br/>
    We therefore seek to determine the coefficients of a quadratic polynomial whose elements are as close as
    possible to the points of a given set (recorded on board a boat, in the following case). <br/>
    <br/>
    The points can be defined (by their coordinates) in different ways, for example, here a compass heading (HDC) and a course over ground (COG) to determine a
    deviation curve, a true wind angle and boat speed to determine polars, etc.<br/><br/>
    For the sake of notation, we will take the coordinate points generically, as follows:
    <table>
        <tr>
            <td>
                <div class="postit">
                    $$
                       P^{HDC}_{COG} = P^x_y
                    $$
                </div>
            </td>
            <td>
                , also written
            </td>
            <td>
                <div class="postit">
                    $$
                       y = f(x)
                    $$
                </div>
            </td>
            <td>
                or
            </td>
            <td>
                <div class="postit">
                    $$
                       f(x) = ax^2 + bx + c
                    $$
                </div>
            </td>
        </tr>
    </table>
    <!--div class="postit">
    $$
       P^{HDC}_{COG} = P^x_y, ecrit aussi f(x) = y, ou f(x) = ax^2 + bx + c
    $$
    </div-->
    herefore, for all points (x,y) in the recorded data cloud, we are looking for the coefficients a, b, and c of a polynomial for which
    <div class="postit">
    $$
    ax^2 + bx + c
    $$
    </div>
    is as close as possible to <code>y</code>, that is to say that the difference
    <div class="postit">
    $$
    ax^2 + bx + c - y
    $$
    </div>
    this difference should be as small as possible, meaning that for all recorded points, the square of this difference should be as close to zero as
    possible (squaring removes the sign,
    hence the name of the method), and therefore the sum of these differences should ultimately be as small as possible.<br/>
    This amounts to calculating the coefficients <code>a</code>, <code>b</code>, and <code>c</code> for which the first derivative of this summation of the squares of the differences with
    respect to each of the coefficients a, b, and c is zero, which can be written as:
    <div class="postit">
    $$ ([\Sigma(ax^2 + bx + c - y)^2])' = 0 $$
    </div>
    <div style="margin: 30px; padding: 5px; border: 1px solid silver; border-radius: 5px;">
        To emphasize: <b>this is the core of the method</b>.<br/>

        <div style="font-style: italic;">
            For all the points in the cloud to be solved, for each <code>x</code>, we calculate the value of the function (here a polynomial) <code>f(x)</code>,
            and we want its difference with <code>y</code> to be as small as possible.<br/>
            <u>Therefore</u>, we want the derivative of the function of this difference (squared, to eliminate any sign issues) to be zero.
        </div>
    </div>
    <table>
        <tr>
            <td>
                <div class="postit smaller-plus">
                    $$ ([\Sigma(ax^2 + bx + c - y)^2])' = 0 $$
                </div>
            </td>
            <td>can be also written</td>
            <td>
                <div class="postit smaller-plus">
                    $$ ([\Sigma((ax^2 + bx + c - y) \times (ax^2 + bx + c - y))])' = 0 $$
                </div>
            </td>
        </tr>
    </table>
    We expand the sum before differentiating:

    <div class="postit smaller-plus">
    $
    S = a^2\Sigma x^4 + 2ab\Sigma x^3 + 2ac\Sigma x^2 - 2a\Sigma yx^2 + b^2\Sigma x^2 + 2bc\Sigma x - 2b\Sigma yx + c^2\Sigma x^0 - 2c\Sigma y + \Sigma y^2
    $
    </div>
    We derive the expression thus obtained
    <ul>
        <li>
            Compared to <code>a</code>:
            <div class="postit">
    $ \dfrac{\partial S}{\partial a} = 2a\Sigma x^4 + 2b\Sigma x^3 + 2c\Sigma x^2 - 2\Sigma yx^2 = 0 $
            </div>
        </li>
        <li>
            Compared to <code>b</code>:
            <div class="postit">
    $ \dfrac{\partial S}{\partial b} = 2a\Sigma x^3 + 2b\Sigma x^2 + 2c\Sigma x^1 - 2\Sigma yx^1 = 0 $
            </div>
        </li>
        <li>
            Compared to <code>c</code>:
            <div class="postit">
    $ \dfrac{\partial S}{\partial c} = 2a\Sigma x^2 + 2b\Sigma x^1 + 2c\Sigma x^0 - 2\Sigma yx^0 = 0 $
            </div>
        </li>
    </ul>
    We swap the y-terms, we simplify by 2:
    <ul>
        <li>
            <div class="postit">
    $ a\Sigma x^4 + b\Sigma x^3 + c\Sigma x^2 = \Sigma yx^2 $
            </div>
        </li>
        <li>
            <div class="postit">
    $ a\Sigma x^3 + b\Sigma x^2 + c\Sigma x^1 = \Sigma yx^1 $
            </div>
        </li>
        <li>
            <div class="postit">
    $ a\Sigma x^2 + b\Sigma x^1 + c\Sigma x^0 = \Sigma yx^0 $
            </div>
        </li>
    </ul>
    and we obtain the following matrix resolution:
    <div class="postit">
    $ \begin{vmatrix} a & b & c \end{vmatrix} = \begin{vmatrix} \Sigma x^4 & \Sigma x^3 & \Sigma x^2 \\ \Sigma x^3 & \Sigma x^2 & \Sigma x^1 \\ \Sigma x^2 & \Sigma x^1 & \Sigma x^0 \end{vmatrix} ^ {-1} \times \begin{vmatrix} \Sigma yx^2 \\ \Sigma yx^1 \\ \Sigma yx^0 \end{vmatrix} $
    </div>
    <i>Notes</i>&nbsp;:
    <br/>
    - The terms $ \Sigma x^0 $ epresent the number of points on the curve to be smoothed.
    <br/>
    - A quadratic polynomial has 3 coefficients, so the dimension of the matrices we are working with (square, row, and column) is 3.
    <p>
    For a polynomial of degree <code>n</code>, the work to be done essentially involves inverting the square matrix $ \Sigma x^{0->2n} $ and
    multiplying it by the column matrix $ \Sigma yx^{0->n} $ to obtain the row matrix of coefficients of the desired polynomial.
    </p>
    <div class="doc-section">
        <h3><a name="least-square-dev">Case of a deviation curve</a></h3>
        <p>
            <hr/>
            <b>Clarification</b>: What exactly is this thing?<br/>
            On board a boat, you have a compass, which allows you to know which direction you're heading, an essential element for dead reckoning.<br/>
            "True north" (geographic north) is the north shown on the charts.<br/>
            "Magnetic heading" takes into account the local magnetic declination (which varies depending on your location on the planet and the date).<br/>
            "Compass heading" is the one indicated by the compass, which is affected by the magnetic influences of the boat itself (metal, electrical equipment, etc.).<br/>
            Deviation is the difference between the compass heading and the magnetic heading.<br/>
            It depends <b>on the boat</b> and its heading, and is therefore a function of the compass heading itself.<br/>
            On a steel boat, it can reach enormous values—like 40 degrees—which it's definitely wise to take into account...
            <hr/>
        </p>
        <p>
            The goal here is to develop a deviation curve from points recorded by the onboard NMEA station.
            <br/>
            DIn this context, the station must include a GPS and a compass (an electronic compass). The GPS will allow the NMEA station to
            generate RMC strings, which will contain the course over ground (COG).
            The compass will provide the station with what it needs to generate compass headings (HDG, HDM, etc., depending on the station).
            <br/>
            The file containing the information produced by the NMEA station will thus look like this:
            <pre class="postit">
    . . .
    $IIRMC,190402,A,0854.980,S,14006.028,W,00.0,008,031110,10,E,A*07
    $IIVHW,,,126,M,00.0,N,,*61
    $IIVLW,02839,N,000.0,N*53
    $IIVWR,027,R,07.2,N,,,,*61
    $IIDPT,012.3,+0.7,*40
    $IIGLL,0854.979,S,14006.029,W,190403,A,A*56
    $IIHDG,126,,,10,E*16
    . . .
            </pre>
            Note that the file may contain other data (VHW, DPT, GLL, VLW, etc.), which we will ignore here.
            <br/>
            This file will then be processed to produce a document containing only the data relevant to our purpose, namely the deviation as a function of heading.
            <br/>
            For example (in <span title="JavaScript Object Notation">JSON</span> here)&nbsp;:
            <pre class="postit">
    [
        { "hdc": 210.000000, "dev": 4.000000 },
        { "hdc": 210.000000, "dev": 4.000000 },
        { "hdc": 210.000000, "dev": -1.000000 },
        { "hdc": 210.000000, "dev": -2.000000 },
        { "hdc": 208.000000, "dev": -4.000000 },
        . . .
    ]
            </pre>
            <div class="screen-only">
                <p>
                    More details on these operations are available in other documents:
                    <ul>
                        <li><a href="https://github.com/OlivierLD/ROB/blob/master/raspberry-sailor/Swing/Deviation-Tool/notebooks/LogfileToDeviation.ipynb" target="NB">Jupyter Notebook, in Java</a></li>
                        <li><a href="https://htmlpreview.github.io/?https://github.com/OlivierLD/ROB/blob/master/raspberry-sailor/Swing/Deviation-Tool/README.html" target="dev-curve">On the process</a></li>
                        <li><a href="https://github.com/OlivierLD/ROB/tree/master/raspberry-sailor/Swing/Deviation-Tool" target="ROB">With examples</a></li>
                        <li><a href="/systems/smoothing.spray.html" target="Smoothing-1">Interactive polynomial smoothing.</a></li>
                    </ul>
                </p>
            </div>
            <br/>
            <br/>
            Therefore, the generic form of a deviation curve is considered to be
            <div class="postit">
            $$
            dev = a + (b \times \cos r) + (c \times \cos r) + (d \times \sin 2r) + (e \times \cos 2r)
            $$
            </div>
            This is clearly <i><b>not a polynomial</b></i>, but since we are looking for the coefficients of the formula, the least squares method can be applied.
            <br/>
            In the equation above, <code>r</code> is the compass heading, and <code>dev</code> is the deviation (&delta; between <code>HDC</code> and <code>HDM</code>, compass heading and magnetic heading).<br/>
            We therefore seek to define a function <code>f</code> for which the deviation <code>dev</code> is obtained by providing <code>r</code>:
            <div class="postit">
                $$ dev = f(r) $$
            </div>
            Thanks to logging, we have a point cloud, each point containing at least the following information:
            <ul>
                <li>HDC (Heading Compass)</li>
                <li>COG (Course Over Ground)</li>
            </ul>
            Logging must be performed without current or drift to ensure that the difference between the compass heading (corrected for local declination) and the course over
            ground (COG) is indeed the deviation <code>d</code> we are looking for. With no drift and no current, the course over ground equals the course through the water,
            which is equal to the boat's true heading.
            <br/>
            The elements of the available point cloud (generated from the logging) are defined in
            <div class="postit">
                $$ P_{d}^{HDC} = P_{d}^{r} = P_{y}^{x} $$
            </div>
            The x-axis represents the compass heading, and the y-axis represents the deviation.
            <br/>
            We are looking for the values of 5 coefficients:
            <div class="postit">
                $ \begin{vmatrix} a & b & c & d & e \end{vmatrix} $
            </div>
            The dimension of the matrices to be managed is therefore 5 this time. We apply the least squares method, described above.
            <br/>
            The coefficients $ \begin{vmatrix} a & b & c & d & e \end{vmatrix} $ are obtained by solving:
            <div class="postit smaller-plus">
$
  \begin{vmatrix} a & b & c & d & e \end{vmatrix}
                =
  \begin{vmatrix}
  &n  &\sum_{i=0}^{n}\sin(r)  &\sum_{i=0}^{n}\cos(r)  &\sum_{i=0}^{n}\sin(2r)  &\sum_{i=0}^{n}\cos(2r) \\
  &\sum_{i=0}^{n}\sin(r)  &\sum_{i=0}^{n}\sin(r)^2  &\sum_{i=0}^{n}\sin(r)cos(r)  &\sum_{i=0}^{n}\sin(2r)sin(r))  &\sum_{i=0}^{n}\cos(2r)sin(r) \\
  &\sum_{i=0}^{n}\cos(r)  &\sum_{i=0}^{n}\cos(r)sin(r)  &\sum_{i=0}^{n}\cos(r)^2  & \sum_{i=0}^{n}\sin(2r)cos(r) &\sum_{i=0}^{n}\cos(2r)cos(r) \\
  &\sum_{i=0}^{n}\sin(2r)  &\sum_{i=0}^{n}\sin(2r)sin(r)  &\sum_{i=0}^{n}\sin(2r)cos(r)  &\sum_{i=0}^{n}\sin(2r)^2  &\sum_{i=0}^{n}\cos(2r)sin(2r) \\
  &\sum_{i=0}^{n}\cos(2r)  &\sum_{i=0}^{n}\cos(2r)sin(r)  &\sum_{i=0}^{n}\cos(2r)cos(r)  &\sum_{i=0}^{n}\cos(2r)sin(2r)  &\sum_{i=0}^{n}\cos(2r)^2
 \end{vmatrix} ^{-1}

\times

 \begin{vmatrix}
  &\sum_{i=0}^{n}\ dev \\
  &\sum_{i=0}^{n}\ dev.sin(r) \\
  &\sum_{i=0}^{n}\ dev.cos(r) \\
  &\sum_{i=0}^{n}\ dev.sin(2r) \\
  &\sum_{i=0}^{n}\ dev.cos(2r)
 \end{vmatrix}

 $
            </div>
            Easy peasy!
            <br>
            <div style="margin-top: 20px;" class="screen-only">
                For more details, see also <a href="https://htmlpreview.github.io/?https://github.com/OlivierLD/ROB/blob/master/raspberry-sailor/Swing/Deviation-Tool/README.html" target="dev-curve">this document</a>,
                and also <a href="https://github.com/OlivierLD/ROB/tree/master/raspberry-sailor/Swing/Deviation-Tool" target="ROB">this one</a>, for a complete example
                (including the code for solving the matrices), starting from the log file, through the calculation of the coefficients, and ending with the display of the deviation curve, with a Web interface.
            </div>
        </p>
    </div>
</section>

<body>


<div id="full-content">

</div>

<hr/>
<address>
    <small>
        &copy; Olivier Le Diouris - 2025<br/>
        <a href="../index.html" target="_top">OlivierLD.github.io</a>
    </small>
</address>
</body>

<script type="text/javascript">

    let navTo = (prm) => {
        let url = window.location.href;
        let newUrl = url.split('?')[0] + '?lang=' + prm;
        console.log("New URL: " + newUrl);
        window.location = newUrl;
    };

    let getQueryParameterByName = (name, url) => {
        if (!url) {
            url = window.location.href;
        }
        name = name.replace(/[\[\]]/g, "\\$&");
        let regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
            results = regex.exec(url);
        if (!results) {
            return null;
        }
        if (!results[2]) {
            return '';
        }
        return decodeURIComponent(results[2].replace(/\+/g, " "));
    };

    let translate = (lang) => {
        let enContent = document.getElementById('en-content');
        let frContent = document.getElementById('fr-content');

        let fullContent = document.getElementById('full-content');
        if (lang === 'FR') {
            // enContent.style.display = 'none';
            // frContent.style.display = 'block';
            fullContent.innerHTML = frContent.innerHTML;
        } else {
            // enContent.style.display = 'block';
            // frContent.style.display = 'none';
            fullContent.innerHTML = enContent.innerHTML;
        }
    };

    window.onload = () => { // Important: window.onload
        let userLang = getQueryParameterByName('lang');
        if (!userLang) {
            let browserUserLang = navigator.language || navigator.userLanguage;
            console.log("The browser's language is: " + browserUserLang);
            if (browserUserLang) {
                if (browserUserLang.substring(0, 2).toUpperCase() === 'FR') {
                    userLang = 'FR';
                    console.log("On va parler français")
                } else {
                    userLang = 'EN';
                    console.log("We'll speak english");
                }
            }
        }
        if (userLang) {
            langToUse = userLang;
            console.log(`Lang to use will be ${langToUse}`);
        }
        if (langToUse !== 'FR') { // Then switch to French, default is EN.
            langToUse = 'EN';
        }
        translate(langToUse);
    };
</script>

</html>
