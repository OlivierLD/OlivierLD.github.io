<!--
    Printable and translatable.
-->
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>GRIBs, polaires, routage</title>
    <!--author>Olivier Le Diouris</author-->
    <meta name="author" content="Olivier Le Diouris">
    <link rel="icon" type="image/png" href="../small.boat.png">
    <!--script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script-->
    <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

    <!--link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script-->

    <!--script type="text/javascript"-->
    <!--script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']]
        }
    });
    </script-->

    <script type="text/javascript">
        // That one is OK for the matrixes.
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        },
        "HTML-CSS": {
            availableFonts: ["TeX"] /* ,
            availableFonts: [],
            // Disable preferred fonts to ensure web fonts are used
            preferredFont: null,
            // Force the use of the Neo-Euler web font for rendering math
            webFont: "TeX" // "Neo-Euler" */
        }
    });
    </script>

    <link rel="stylesheet" href="../../nse/main.css" />
    <!-- link rel="stylesheet" media="screen" href="main.css" /-->
    <link rel="stylesheet" media="print" href="../../nse/print.css" />

    <style type="text/css">
        body {
            width: fit-content;
        }
    </style>
</head>

<body>

<section id="fr-content" style="display: none;">

    <h1><a name="least-squares">GRIBs, polaires, routage</a></h1>
    <span class="screen-only">Traduisible et imprimable - La version '&eacute;cran' contient des liens qui n'apparaissent pas dans la version imprimable.</span>
    <a class="screen-only" href="javascript:void(0)" onclick="navTo('EN');"><img src="../../../systems/images/us_uk_flag.png" style="width: 30px;" title="In English" alt="In English"></a>
    <hr class="screen-only"/>
    <div class="screen-only">
        Sommaire :
        <ul>
            <li><a href="#grib">GRIB</a></li>
            <li><a href="#polars">Polaires</a></li>
            <li><a href="#routing">Routage</a></li>
        </ul>
    </div>
    <hr class="screen-only"/>
    <p>
        On veut en d&eacute;finitive faire un routage pour le bateau, c'est &agrave; dire de d&eacute;terminer la route optimale entre un point de d&eacute;part et un point d'arriv&eacute;e, en tenant compte des conditions m&eacute;t&eacute;orologiques (vent, courant, vagues) et des performances du bateau (polaires).<br/>
        Pour cela, il faut disposer de plusieurs &eacute;lements :<br/>
        <ul>
            <li>Les polaires du bateau</li>
            <li>Les donn&eacute;es m&eacute;t&eacute;orologiques, g&eacute;n&eacute;ralement au format GRIB</li>
            <li>Un algorithme de routage</li>
        </ul>
        Ce document pr&eacute;sente ces diff&eacute;rents &eacute;l&eacute;ments, et donne quelques pistes pour r&eacute;aliser un tel routage.
    </p>
    <p>
        <div style="display: grid; grid-template-columns: auto auto; gap: 20px;">
            <h2><a name="grib">GRIB</a></h2>
            <div class="screen-only" style="text-align: right; margin-top: 20px;"><a href="#">Top</a></div>
        </div>
        L'acronyme GRIB signifie "GRIdded Binary" (binaire en grille).<br/>
        C'est un format de fichier binaire standard pour la diffusion de donn&eacute;es m&eacute;t&eacute;orologiques.<br/>
        Il est utilis&eacute; pour transmettre des pr&eacute;visions m&eacute;t&eacute;orologiques, notamment les vents, la pression atmosph&eacute;rique, les temp&eacute;ratures, etc., sur une grille g&eacute;ographique
        et temporelle.<br/>
        Pour obtenir des fichiers GRIB, il faut addresser une requ&ecirc;te &agrave; un serveur de donn&eacute;es m&eacute;t&eacute;orologiques, en pr&eacute;cisant la r&eacute;gion g&eacute;ographique, la p&eacute;riode et les param&egrave;tres souhait&eacute;s.<br/>
        Pour la zone, et la p&eacute;riode, on pr&eacute;cisera aussi le maillage (r&eacute;solution) de la grille.<br/>
        <i>Exemple :</i>
        <div class="postit bordered-box">
            GFS:65N,45S,130E,110W|2,2|0,6..24|PRMSL,WIND,HGT500,TEMP,WAVES,RAIN
        </div>
        La requ&ecirc;te ci-dessus concerne :<br/>
        <ul>
            <li>la zone g&eacute;ographique d&eacute;limit&eacute;e par les coordonn&eacute;es 65N,45S,130E,110W (coin sup&eacute;rieur gauche 65N-130E, coin inf&eacute;rieur droit 45S-110E), c'est l'Oc&eacute;an Pacifique</li>
            <li>un maillage de 2&deg; en latitude et 2&deg; en longitude</li>
            <li>des pr&eacute;visions &agrave; 0h, 6h, 12h, 18h et 24h (toutes les 6H, pendant 24H)</li>
            <li>les param&egrave;tres suivants : pression au niveau de la mer (PRMSL), vent (WIND), hauteur g&eacute;opotentielle &agrave; 500 hPa (HGT500), temp&eacute;rature (TEMP), vagues (WAVES) et pr&eacute;cipitations (RAIN)</li>
        </ul>
        La taille du fichier GRIB esp&eacute;r&eacute; est bien &eacute;videmment fonction de la taille de la zone, du maillage, de la p&eacute;riode et des param&egrave;tres demand&eacute;s.<br/>
        Plus le maillage est serr&eacute;, plus les param&egrave;tres sont nombreux, plus la p&eacute;riode est longue, plus le fichier sera volumineux.<br/>
        <div style="font-style: italic; margin: 10px; padding: 5px; border: 1px solid gray; border-radius: 5px; background-color: #f0f0f0;">
            <b>Note :</b><br/>
            Afin de diminuer la taille des fichiers &agrave; recevoir - on n'a pas toujours un d&eacute;bit Internet infini - on peut jouer sur le maillage, et proc&eacute;der ensuite &agrave; un lissage des donn&eacute;es.<br/>
            &Ccedil;a n'est certes pas aussi pr&eacute;cis, mais bien souvent le r&eacute;sutat est suffisant pour la navigation de plaisance.
        </div>
        <div>
            Le fichier re&ccedil;u apr&egrave;s la requ&ecirc;te est un fichier binaire (num&eacute;rique), illisible en l'&eacute;tat.<br/>
            Mais son contenu peut &ecirc;tre visualis&eacute; avec un logiciel adapt&eacute; (on y reviendra). <!--, par exemple <a class="list-link" href="https://www.zygrib.org/" target="zyGrib">zyGrib</a> (gratuit).--><br/>
            Le format de son contenu peut sans ausun doute &ecirc;tre compare &agrave; celui d'une feuille Excel (on dit feuille de calcul !), avec des lignes et des colonnes, chaque cellule contenant une valeur pour un param&egrave;tre donn&eacute; (vent, pression, temp&eacute;rature, etc) &agrave; une
            position g&eacute;ographique (latitude, longitude) et &agrave; un instant donn&eacute; (heure de la pr&eacute;vision).<br/>
            <div style="text-align: center;">
                <img src="docs/grib.04.png" title="Contenu du GRIB" style="max-width: 60%; border: 1px solid black;"/>
            </div>
            Au dessus, les onglets correspondant aux diff&eacute;rentes dates et heures, en dessous, les onglets des param&egrave;tres disponibles.<br/>
        </div>
        <div style="margin-top: 10px;">
            Voyons la requ&ecirc;te suivante :
            <div class="postit bordered-box">
                GFS:65N,14N,100W,10E|4,4|0,12..168|PRMSL,WIND,HGT500,TEMP,WAVES,RAIN
            </div>
            On y remarque que le maillage est de 4&deg; en latitude et 4&deg; en longitude, au lieu de 2&deg; dans l'exemple pr&eacute;c&eacute;dent,
            et qu'on aura un grib toutes les 12 heures, au lieu de 6 pr&eacute;c&eacute;demment.<br/>
            Ceci devrait all&eacute;ger la taille du <a href="docs/NorthAtlantic_2025_12_23_09_10_41_CET.grb">fichier</a> &agrave; recevoir.<br/>
            En revanche, la d&eacute;finition est moindre, ainsi qu'on peut le voir ici :<br/>
            <div style="text-align: center;">
                <img src="docs/grib.01.png" title="Cellulles de 4 degr&eacute;s" style="max-width: 80%; border: 1px solid black;"/>
            </div>
            On voit bien que la d&eacute;finition du vent est moins bonne.<br/>
            Le lissage peut r&eacute;soudre cette situation, en appliquant un lissage de facteur 4 (on divise chaque cellule en 4&times;4=16).<br/>
            <div style="text-align: center;">
                <img src="docs/grib.02.png" title="Celulles de 1 degr&eacute;" style="max-width: 80%; border: 1px solid black;"/>
            </div>
            Ce lissage est appliqu&eacute; ici au vent, il s'appliquera de m&ecirc;me aux autres param&egrave;tres (PRMSL, 500MB, RAIN, TEMP, etc).<br/>
            Le lissage appliqu&eacute; ici est g&eacute;ographique, il peut aussi s'appliquer dans le temps, pour passer d'un intervalle de 12 heures &agrave; un intervalle de 3 heures, par exemple.<br/>
            <br/>
            Il peut aussi parfois &ecirc;tre int&eacute;ressant d'afficher les donn&eacute;es du GRIB en 3D :
            <div style="text-align: center;">
                <img src="docs/grib.03.png" title="PRMSL &amp; 500MB" style="max-width: 80%; border: 1px solid black;"/>
            </div>
        </div>
        <br/>
        Le standard des fichiers GRIB a deux versions (1, et 2). Il convient pour les exploiter de savoir quelle est la version du fichier re&ccedil;u, et de disposer d'un logiciel adapt&eacute;.<br/>
        <h3>Envoi d'une requ&ecirc;te</h3>
        On peut enover la requ&ecirc;te ci-dessus &agrave; <code>query@saildocs.com</code>, par email.<br/>
        Le sujet de l'email n'a pas d'importance, le corps du message contient la requ&ecirc;te, en <i><b>plain text</b></i>.<br/>
        Par exemple <a href="mailto:query@saildocs.com?subject=GRIBRequest&body=GFS:65N,45S,130E,110W|2,2|0,6..24|PRMSL,WIND,HGT500,TEMP,WAVES,RAIN" target="new">envoyer cette requ&ecirc;te</a> par email &agrave; Saildocs.<br/>
        La r&eacute;ponse arrive en g&eacute;n&eacute;ral en quelques minutes - voire secondes, avec un <a href="docs/GFS20251221161301416.grb">fichier GRIB</a> en pi&egrave;ce jointe.<br/>
        Plusieurs services permettent d'envoyer des requ&ecirc;tes GRIB, par exemple :<br/>
        <ul>
            <li><a class="list-link" href="https://www.ncei.noaa.gov/products/weather-climate-models/global-forecast-system" target="NCEI">NOAA NCEI GFS</a></li>
            <li><a class="list-link" href="https://www.ventusky.com/" target="Ventusky">Ventusky</a></li>
            <li><a class="list-link" href="https://www.passageweather.com/grib-files/" target="PassageWeather">Passage Weather</a></li>
            <li><a class="list-link" href="https://saildocs.com/" target="SailMail">https://saildocs.com/</a></li>
        </ul>
    </p>

    <p>
        <div style="display: grid; grid-template-columns: auto auto; gap: 20px;">
            <h2><a name="polars">Polaires</a></h2>
            <div class="screen-only" style="text-align: right; margin-top: 20px;"><a href="#">Top</a></div>
        </div>
        Les polaires d'un bateau sont des courbes qui repr&eacute;sentent la vitesse du bateau en fonction de l'angle et de la force du vent apparent.<br/>
        Le vent apparent est celui qui fait avancer un voilier, c'est la combinaison du vent r&eacute;el et de la vitesse du bateau.<br/>
        Le vent apparent d&eacute;pendant du vent r&eacute;el et de la vitesse du bateau, les polaires permettent de d&eacute;terminer la vitesse du bateau pour une direction et une force de vent donn&eacute;es.<br/>

        Voir <a href="https://github.com/OlivierLD/ROB/blob/master/raspberry-sailor/PolarSmoother/README.md" target="PolarSmoother">ici</a> pour un outil de lissage des polaires.<br/>
        <br/>
        Les polaires sont des fonctions de deux variables : l'angle du vent apparent (AWA, Apparent Wind Angle) et la force du vent apparent (AWS, Apparent Wind Speed).<br/>
        Elles peuvent fr&eacute;quement &ecirc;tre repr&eacute;sent&eacute;es par une ou plusieurs fonctions polyn&ocirc;mes.<br/>
        <br/>
        On peut pour &eacute;laborer les polaires d'un bateau utiliser des donn&eacute;es de navigation r&eacute;elles, enregistr&eacute;es lors de sorties en mer.<br/>
        <div style="text-align: center;">
            <img src="docs/polar.01.png" title="Raw data" style="max-width: 40%; border: 1px solid black;"/>
        </div>
        On peut ensuite choisir le degr&eacute; des polyn&ocirc;mes &agrave; utiliser pour le lissage, et utiliser une m&eacute;thode de moindres carr&eacute;s
        (voir <a href="../../../systems/least.squares.html?lang=FR" target="MC">ici</a>) pour ajuster les polaires aux donn&eacute;es brutes.<br/>
        <br/>
        On appelle ces courbes des "polaires" car elles sont souvent repr&eacute;sent&eacute;es dans un syst&egrave;me de coordonn&eacute;es polaires, o&ugrave; l'angle est l'angle du vent apparent, et la distance au centre est la vitesse du bateau.<br/>
        Elles peuvent cependant &ecirc;tre repr&eacute;sent&eacute;es dans un syst&egrave;me de coordonn&eacute;es cart&eacute;siennes, o&ugrave; - par exemple - l'axe des Y repr&eacute;sente l'angle du vent apparent, et l'axe des X la vitesse du bateau.
        C'est moins intuitif...<br/>
        <div style="display: grid; grid-template-columns: auto auto auto; margin: 10px;">
            <div style="text-align: center;">
                <img src="docs/polar.02.png" title="Raw data" style="max-width: 90%; border: 1px solid black;"/>
                <br/>
                Coordonn&eacute;es polaires
            </div>
            <div style="text-align: center;">
                <img src="docs/polar.03.png" title="Raw data" style="max-width: 90%; border: 1px solid black;"/>
                <br/>
                Coordonn&eacute;es cart&eacute;siennes
            </div>
            <div style="text-align: center;">
                <img src="docs/polar.04.png" title="Raw data" style="max-width: 90%; border: 1px solid black;"/>
                <br/>
                Degr&eacute;s des polyn&ocirc;mes
            </div>
        </div>
        On voit sur la troisi&egrave;me image le degr&eacute; choisi pour les polyn&ocirc;mes.<br/>
        On distingue le degr&eacute; des polaires (5 ci-dessus), et le degr&eacute; des coefficients (3 ci-dessus).<br/>
        Le degr&eacute; des polaires d&eacute;finit la complexit&eacute; de la courbe, le degr&eacute; des coefficients d&eacute;finit le polyn&ocirc;me qui permettra de d&eacute;terminer les coefficients de la polaire pour une force de vent donn&eacute;e.<br/>
        Ainsi, les polaires auront la forme
        $$ V_{boat} (x, AWS) = a_{AWS}.x^5 + b_{AWS}.x^4 + c_{AWS}.x^3 + d_{AWS}.x^2 + e_{AWS}.x^1  + f_{AWS} $$
        o&ugrave; $ x $ est l'angle du vent apparent, et les coefficients $a_{AWS}$, $b_{AWS}$, $c_{AWS}$, $d_{AWS}$, $e_{AWS}$ et $f_{AWS}$ d&eacute;pendent de la force du vent apparent (AWS), suivant une fonction polyn&ocirc;me de degr&eacute; 3 :<br/>
        $$ a_{AWS} = A.AWS^3 + B.AWS^2 + C.AWS + D, etc. $$ <br/>
        Ainsi, pour tout angle de vent ($ x, ou AWA $) et pour toute force de vent ($ AWS $) donn&eacute;e, on peut calculer la vitesse du bateau ($ V_{boat} $).<br/>
        Les polaires ainsi g&eacute;n&eacute;r&eacute;es peuvent aussi &ecirc;tre visualis&eacute;es en 3D.<br/>
        <div style="display: grid; grid-template-columns: auto auto; margin: 10px;">
            <div style="text-align: center;">
                <img src="docs/polar.05.png" title="Raw data" style="max-width: 90%; border: 1px solid black;"/>
            </div>
            <div style="text-align: center;">
                <img src="docs/polar.06.png" title="Raw data" style="max-width: 90%; border: 1px solid black;"/>
            </div>
        </div>
    </p>

    <p>
        <div style="display: grid; grid-template-columns: auto auto; gap: 20px;">
            <h2><a name="routing">Routage</a></h2>
            <div class="screen-only" style="text-align: right; margin-top: 20px;"><a href="#">Top</a></div>
        </div>
        Attention, c'est l&agrave; que les choses se compliquent un peu..., tout s'assemble !<br/>
        <p>
            On a vu pr&eacute;c&eacute;demment comment obtenir les donn&eacute;es m&eacute;t&eacute;orologiques (GRIB), et comment d&eacute;finir les performances du bateau (polaires).<br/>
            Il reste &agrave; d&eacute;terminer un algorithme de routage, qui permettra de trouver le chemin optimal entre un point de d&eacute;part et un point d'arriv&eacute;e,
            en tenant compte des conditions m&eacute;t&eacute;orologiques et des performances du bateau.<br/>
            Ceci fait intervenir une quantit&eacute; importante de calculs, car &agrave; chaque instant, la position du bateau d&eacute;pend de la direction et de la force du vent, qui varient dans le temps et l'espace.<br/>
            Il est clairement impensable de faire cela &agrave; la main, m&ecirc;me avec une calculatrice !<br/>
            C'est un travail &agrave; confier &agrave; un ordinateur, avec un algorithme adapt&eacute;.
        </p>

        Plusieurs algorithmes de routage existent, avec des degr&eacute;s de complexit&eacute; variables.<br/>
        Le plus simple est le routage par Dijkstra, qui permet de trouver le chemin le plus court entre deux points dans un graphe pond&eacute;r&eacute;.<br/>
        <div style="font-style: italic; margin: 10px; padding: 5px; border: 1px solid gray; border-radius: 5px; background-color: #f0f0f0;">
            <b>Note : Objectifs du Routage</b><br/>
            En course, il s'agit &eacute;videmment d'arriver le plus vite possible &agrave; destination.<br/>
            En croisi&egrave;re, on peut aussi vouloir &eacute;viter les zones de mauvais temps, ou au contraire profiter de certaines conditions m&eacute;t&eacute;orologiques particuli&egrave;res.<br/>
            Le routage peut donc int&eacute;grer des crit&egrave;res suppl&eacute;mentaires, en plus du temps de parcours.<br/>
            Genre "Quarante n&oelig;uds sur le nez, non merci !"
        </div>
        <h3>Isochrones</h3>
        Les isochrones sont le lieu des positions atteignables par le bateau en un temps donn&eacute; (iso - &iota;&sigma;&omicron;: identique, chronos - &chi;&rho;&omicron;&nu;&omicron;&sigma; : temps. IsoChrone &rarr; temps identique. Lieu de points atteignables dans le m&ecirc;me temps.).<br/>
        Une m&eacute;thode de routage couramment utilis&eacute;e est la m&eacute;thode des isochrones.<br/>
        Elle consiste &agrave; tracer des lignes isochrones, c'est-&agrave;-dire des lignes qui repr&eacute;sentent les positions atteignables par le bateau en un temps donn&eacute;.<br/>
        En utilisant les polaires du bateau et les donn&eacute;es m&eacute;t&eacute;orologiques (GRIB), on peut calculer les isochrones &agrave; intervalles de temps r&eacute;guliers, en tenant compte des conditions de vent et de courant.<br/>
        En reliant les isochrones successifs, on obtient un graphe de positions possibles.<br/>
        On peut alors appliquer un algorithme de recherche de chemin (comme Dijkstra) pour trouver le chemin optimal entre le point de d&eacute;part et le point d'arriv&eacute;e.<br/>
        <h3>Enveloppes Convexes</h3>
        Donc, comme d&eacute;crit ci-dessus, &agrave; partir de la position de d&eacute;part, on calcule les lieu des points atteignables en un temps donn&eacute; - disons ici, par exemple, 3 heures - le calcul des
        points est fait par exemple tous les 10 degr&eacute;s.<br/>
        On obtient donc 36 points (360/10).<br/>
        De chacun de ces 36 points, on refait le m&ecirc;me calcul, pour obtenir les points atteignables en 3 heures suppl&eacute;mentaires (soit 6 heures depuis le d&eacute;part).<br/>
        Ce calcul s'effectue avec les donn&eacute;es du GRIB, pour chacun des points du premier isochone (o&ugrave; les conditions sont maintenant diff&eacute;rentes les unes des autres).<br/>
        On obtient donc 36 &times; 36 = 1.296 points.<br/>
        On continue ainsi jusqu'&agrave; atteindre le point d'arriv&eacute;e.<br/>
        Le nombre de points &agrave; g&eacute;rer devient rapidement tr&egrave;s important (voire trop), c'est exponentiel !<br/>
        Au troisi&egrave;me isochrone, on aura 36 &times; 36 &times; 36 = 46.656 points, 1.679.616 au quatri&egrave;me ! Et ainsi de suite...<br/>
        Ceci peut mettre n'importe quel ordinateur - si puissant soit-il - sur le toit avant d'atteindre la destination.<br/>
        Il est donc n&eacute;cessaire de r&eacute;duire le nombre de points de chaque isochrone.<br/>
        Une m&eacute;thode efficace est d'utiliser l'enveloppe convexe des points.<br/><br/>
        L'enveloppe convexe est le plus petit polygone convexe qui contient tous les points.<br/>
        <i><b>Intuitivement</b></i>, c'est comme de mettre un &eacute;lastique autour des points, l'&eacute;lastique va se tendre pour englober tous les points, formant ainsi l'enveloppe convexe.<br/>
        En ne gardant que les points de l'enveloppe convexe (en &eacute;liminant ceux qui sont &agrave; l'int&eacute;rieur de l'&eacute;lastique), on r&eacute;duit significativement le nombre de points &agrave; g&eacute;rer.
        <div style="text-align: center;">
            <img src="docs/enveloppe.png" title="enveloppe convexe" style="max-width: 40%; border: 1px solid black;"/>
        </div>
        En rouge, les points du premier isochrone.<br/>
        En jaune et vert, ceux du deuxi&egrave;me.<br/>
        Seuls les points de l'enveloppe convexe (en vert) sont conserv&eacute;s. Les jaunes sont &eacute;limin&eacute;s.<br/>
        Voir ci-dessous les effets de la m&eacute;thode sur un vrai routage (ne pas h&eacute;siter &agrave; zoomer) :
        <div style="text-align: center;">
            <img src="docs/routing.01.png" title="Routing" style="max-width: 80%; border: 1px solid black;"/>
        </div>
        Le r&eacute;sultat final est le chemin optimal (en bleu) entre le point de d&eacute;part et le point d'arriv&eacute;e.<br/>
        Ce r&eacute;sultat peut ensuite &ecirc;tre export&eacute; sous diff&eacute;rents formats, afin d'&eacute;tre utilis&eacute; par un logiciel de
        navigation (par exemple au format GPX, mais c'est loin d'&ecirc;tre le seul format disponible).<br/>
    </p>
    <p class="screen-only">
        Toutes les saisies d'&eacute;cran ci-dessus proviennent d'un logiciel de routage et de navigation, d&eacute;velopp&eacute; en Java (entre autres langages).
        Tout le code source est disponible dans son <a class="list-link" href="https://github.com/OlivierLD/ROB/tree/master/raspberry-sailor/Swing/WeatherWizard" target="GitHub">r&eacute;f&eacute;rentiel GitHub</a>.<br/>
        Le manuel utilisateur est <a href="http://www.lediouris.net/donpedro/software/structure/datafiles/manual/WeatherWizardUserManual.2nd.edition.pdf" target="WW">ici</a>.
    </p>

</section>

<section id="en-content" style="display: none;">
    <h1><a name="least-squares">GRIBs, polars, routing</a></h1>
    <span class="screen-only">Translatable and printable - The screen version contains links that do not show up in the print one.</span>
    <a class="screen-only" href="javascript:void(0)" onclick="navTo('FR');"><img src="../../../systems/images/france.gif" style="width: 30px;" title="En fran&ccedil;ais" alt="En fran&ccedil;ais"></a>

    <hr class="screen-only"/>
    <div class="screen-only">
        Summary :
        <ul>
            <li><a href="#grib">GRIB</a></li>
            <li><a href="#polars">Polars</a></li>
            <li><a href="#routing">Routing</a></li>
        </ul>
    </div>
    <hr class="screen-only"/>
    <p>
        Ultimately, we want to create a route for the boat, that is, determine the optimal route between a starting point and a destination,
        taking into account weather conditions (wind, current, waves) and the boat's performance (polar diagrams).<br/>
        To do this, several elements are needed:<br/>
        <ul>
            <li>The boat's polars</li>
            <li>Weather data, usually in GRIB format</li>
            <li>A routing algorithm</li>
        </ul>
        This document presents these different elements, and gives some guidance on how to carry out such routing.
    </p>
    <p>
        <div style="display: grid; grid-template-columns: auto auto; gap: 20px;">
            <h2><a name="grib">GRIB</a></h2>
            <div class="screen-only" style="text-align: right; margin-top: 20px;"><a href="#">Top</a></div>
        </div>
        The acronym GRIB stands for "GRIdded Binary".<br/>
        It is a standard binary file format for disseminating meteorological data.<br/>
        It is used to transmit weather forecasts, including wind, atmospheric pressure, temperature, etc., on a geographic and temporal grid.<br/>
        To obtain GRIB files, a request must be sent to a meteorological data server, specifying the geographic region, the time period, and the desired parameters.<br/>
        For the area and time period, the grid resolution must also be specified.<br/>
        <i>Example :</i>
        <div class="postit bordered-box">
            GFS:65N,45S,130E,110W|2,2|0,6..24|PRMSL,WIND,HGT500,TEMP,WAVES,RAIN
        </div>
        The above request concerns:<br/>
        <ul>
            <li>The geographical area delimited by the coordinates 65N, 45S, 130E, 110W (upper left corner 65N-130E, lower right corner 45S-110E) is the Pacific Ocean.</li>
            <li>a grid of 2° in latitude and 2° in longitude</li>
            <li>orecasts at 0am, 6am, 12pm, 6pm and 24h (every 6 hours, for 24 hours)</li>
            <li>the following parameters: sea level pressure (PRMSL), wind (WIND), 500 hPa geopotential height (HGT500), temperature (TEMP), waves (WAVES) and precipitation (RAIN)</li>
        </ul>
        The expected GRIB file size obviously depends on the size of the area, the grid resolution, the time period, and the parameters requested.<br/>
        The finer the grid resolution, the more parameters there are, and the longer the time period, the larger the file will be.<br/>
        <div style="font-style: italic; margin: 10px; padding: 5px; border: 1px solid gray; border-radius: 5px; background-color: #f0f0f0;">
            <b>Note:</b><br/>
            To reduce the size of the files to be received — since unlimited internet bandwidth isn't always available — you can adjust the network mesh and then smooth the data.<br/>
            While not as precise, the result is often sufficient for recreational navigation.
        </div>
        <div>
            The file received after the request is a binary (digital) file, unreadable in its current state.<br/>
            However, its contents can be viewed with suitable software (we'll come back to that). Its format can undoubtedly be compared to that of an Excel spreadsheet,
            with rows and columns, each cell containing a value for a given parameter (wind, pressure, temperature, etc.) at a specific geographic location (latitude, longitude)
            and at a given time (the forecast time).<br/>
            <div style="text-align: center;">
                <img src="docs/grib.04.png" title="Contenu du GRIB" style="max-width: 60%; border: 1px solid black;"/>
            </div>
            Above are the tabs corresponding to the different dates and times, below are the tabs for the available settings.<br/>
        </div>
        <div style="margin-top: 10px;">
            Let's look at the following query:
            <div class="postit bordered-box">
                GFS:65N,14N,100W,10E|4,4|0,12..168|PRMSL,WIND,HGT500,TEMP,WAVES,RAIN
            </div>
            Note that the grid spacing is 4° in latitude and 4° in longitude, instead of 2° in the previous example, and that a GRIB file will be
            generated every 12 hours, instead of every 6 hours previously.<br/>
            This should reduce the size of the <a href="docs/NorthAtlantic_2025_12_23_09_10_41_CET.grb">received file</a>.<br/>
            However, the resolution is lower, as can be seen here:<br/>
            <div style="text-align: center;">
                <img src="docs/grib.01.png" title="Cellulles de 4 degr&eacute;s" style="max-width: 80%; border: 1px solid black;"/>
            </div>
            It's clear that the wind definition is less accurate.<br/>
            Smoothing can resolve this issue by applying a smoothing factor of 4 (dividing each cell into 4&times;4=16).<br/>
            <div style="text-align: center;">
                <img src="docs/grib.02.png" title="Celulles de 1 degr&eacute;" style="max-width: 80%; border: 1px solid black;"/>
            </div>


            This smoothing is applied here to the wind; it will be applied similarly to the other parameters (PRMSL, 500MB, RAIN, TEMP, etc.).<br/>
            LThe smoothing applied here is geographical; it can also be applied over time, for example, to go from a 12-hour interval to a 3-hour interval.<br/>
            <br/>
            It can also sometimes be useful to display the GRIB data in 3D.
            <div style="text-align: center;">
                <img src="docs/grib.03.png" title="PRMSL &amp; 500MB" style="max-width: 80%; border: 1px solid black;"/>
            </div>
        </div>
        <br/>
        The GRIB file standard has two versions (1 and 2). To use them, you need to know which version the received file is and have suitable software.<br/>
        <h3>Sending a request</h3>
        The above request can be sent to <code>query@saildocs.com</code> by email.<br/>
        The email subject doesn't matter; the body of the message contains the request in <i><b>plain text</b></i>.<br/>
        For example <a href="mailto:query@saildocs.com?subject=GRIBRequest&body=GFS:65N,45S,130E,110W|2,2|0,6..24|PRMSL,WIND,HGT500,TEMP,WAVES,RAIN" target="new">send this request</a> by email to Saildocs.<br/>
        The response usually arrives within minutes — if not seconds — with a <a href="docs/GFS20251221161301416.grb">GRIB file</a> attached.<br/>
        Several services allow you to send GRIB requests, for example:<br/>
        <ul>
            <li><a class="list-link" href="https://www.ncei.noaa.gov/products/weather-climate-models/global-forecast-system" target="NCEI">NOAA NCEI GFS</a></li>
            <li><a class="list-link" href="https://www.ventusky.com/" target="Ventusky">Ventusky</a></li>
            <li><a class="list-link" href="https://www.passageweather.com/grib-files/" target="PassageWeather">Passage Weather</a></li>
            <li><a class="list-link" href="https://saildocs.com/" target="SailMail">https://saildocs.com/</a></li>
        </ul>
    </p>

    <p>
        <div style="display: grid; grid-template-columns: auto auto; gap: 20px;">
            <h2><a name="polars">Polars</a></h2>
            <div class="screen-only" style="text-align: right; margin-top: 20px;"><a href="#">Top</a></div>
        </div>
        A boat's polars are curves that represent the boat's speed as a function of the apparent wind angle and strength.<br/>
        The apparent wind is the force that propels a sailboat; it's the combination of the true wind and the boat's speed.<br/>
        Since the apparent wind depends on the true wind and the boat's speed, polars allow us to determine the boat's speed for a given wind direction and speed.<br/>
        See <a href="https://github.com/OlivierLD/ROB/blob/master/raspberry-sailor/PolarSmoother/README.md" target="PolarSmoother">here</a> for a polar smoothing tool.<br/>
        <br/>
        Polars are functions of two variables: the apparent wind angle (AWA) and the apparent wind speed (AWS).<br/>
        They can often be represented by one or more polynomial functions.<br/>
        <br/>
        Real-world sailing data, recorded during sea trials, can be used to create a boat's polars.<br/>
        <div style="text-align: center;">
            <img src="docs/polar.01.png" title="Raw data" style="max-width: 40%; border: 1px solid black;"/>
        </div>
        We can then choose the degree of the polynomials to use for smoothing, and use a least-squares method
        (see <a href="../../../systems/least.squares.html?lang=EN" target="MC">here</a>) to fit the polars to the raw data.<br/>
        <br/>
        These curves are called "polars" because they are often represented in a polar coordinate system, where the angle is the apparent wind angle, and the distance from
        the center is the boat's speed.<br/>
        However, they can also be represented in a Cartesian coordinate system, where — for example — the Y-axis represents the apparent wind angle, and the X-axis the boat's speed.
        This is less intuitive...<br/>
        <div style="display: grid; grid-template-columns: auto auto auto; margin: 10px;">
            <div style="text-align: center;">
                <img src="docs/polar.02.png" title="Raw data" style="max-width: 90%; border: 1px solid black;"/>
                <br/>
                Polar coordinates
            </div>
            <div style="text-align: center;">
                <img src="docs/polar.03.png" title="Raw data" style="max-width: 90%; border: 1px solid black;"/>
                <br/>
                Cartesian coordinates
            </div>
            <div style="text-align: center;">
                <img src="docs/polar.04.png" title="Raw data" style="max-width: 90%; border: 1px solid black;"/>
                <br/>
                Degrees of polynomials
            </div>
        </div>
        The third image shows the degree chosen for the polynomials.<br/>
        We distinguish between the degree of the polars (5 above) and the degree of the coefficients (3 above).<br/>
        The degree of the polars defines the complexity of the curve, while the degree of the coefficients defines the polynomial that will
        determine the coefficients of the polar for a given wind force.<br/>
        Thus, the polars will have the form
        $$ V_{boat} (x, AWS) = a_{AWS}.x^5 + b_{AWS}.x^4 + c_{AWS}.x^3 + d_{AWS}.x^2 + e_{AWS}.x^1  + f_{AWS} $$
        where $ x $ is the angle of the apprent wind, and the coefficients $a_{AWS}$, $b_{AWS}$, $c_{AWS}$, $d_{AWS}$, $e_{AWS}$ et $f_{AWS}$ depend on the apparent wind speed (AWS), according to a polynomial function of degree 3:<br/>
        $$ a_{AWS} = A.AWS^3 + B.AWS^2 + C.AWS + D, etc. $$ <br/>
        Thus, for any wind angle ($ x, aka AWA $) and for any wind force ($ AWS $), given this data, we can calculate the speed of the boat ($ V_{boat} $).<br/>
        The polars thus generated can also be visualized in 3D.
        <div style="display: grid; grid-template-columns: auto auto; margin: 10px;">
            <div style="text-align: center;">
                <img src="docs/polar.05.png" title="3D data" style="max-width: 90%; border: 1px solid black;"/>
            </div>
            <div style="text-align: center;">
                <img src="docs/polar.06.png" title="3D data" style="max-width: 90%; border: 1px solid black;"/>
            </div>
        </div>
    </p>

    <p>
        <div style="display: grid; grid-template-columns: auto auto; gap: 20px;">
            <h2><a name="routing">Routing</a></h2>
            <div class="screen-only" style="text-align: right; margin-top: 20px;"><a href="#">Top</a></div>
        </div>
        Careful, this is where things get a little complicated... everything comes together!<br/>
        <p>
            We previously saw how to obtain meteorological data (GRIB files) and how to define the boat's performance (polar diagrams).<br/>
            It remains to determine a routing algorithm that will find the optimal path between a starting point and a destination, taking into account weather conditions and the boat's performance.<br/>
            This involves a significant amount of calculation, because at any given moment, the boat's position depends on the wind direction and strength, which vary over time and space.<br/>
            It is clearly impossible to do this manually, even with a calculator!<br/>
            This task must be entrusted to a computer, using a suitable algorithm.
        </p>

        Several routing algorithms exist, with varying degrees of complexity.<br/>
        The simplest is Dijkstra's routing, which finds the shortest path between two points in a weighted graph.<br/>
        <div style="font-style: italic; margin: 10px; padding: 5px; border: 1px solid gray; border-radius: 5px; background-color: #f0f0f0;">
            <b>Note: Routing Objectives</b><br/>
            When racing, the goal is obviously to reach the destination as quickly as possible.<br/>
            When cruising, you might also want to avoid areas of bad weather, or conversely, take advantage of specific weather conditions.<br/>
            Routing can therefore incorporate additional criteria, beyond just travel time.<br/>
            For example, "Forty knots on the nose? No thanks!"
        </div>
        <h3>Isochrones</h3>
        Isochrones are the locus of positions reachable by a boat in a given time (iso - &iota;&sigma;&omicron;: identical,
        chronos - &chi;&rho;&omicron;&nu;&omicron;&sigma;: time. IsoChrone &rarr; identical time. Location of points reachable in the same time).<br/>
        A commonly used routing method is the isochrone method.<br/>
        It consists of drawing isochrone lines, that is, lines that represent the positions reachable by the boat in a given time.<br/>
        Using the boat's polar diagrams and meteorological data (GRIB), isochrones can be calculated at regular time intervals, taking into account wind and current conditions.<br/>
        By connecting successive isochrones, a graph of possible positions is obtained.<br/>
        A pathfinding algorithm (such as Dijkstra's algorithm) can then be applied to find the optimal path between the starting point and the destination.

        <h3>Convex Envelopes</h3>
        So, as described above, starting from the initial position, we calculate the locations of points reachable within a given time—let's say, for example, 3 hours—with the calculation performed every 10 degrees.
        This gives us 36 points (360/10).<br/>
        For each of these 36 points, we repeat the same calculation to obtain the points reachable in an additional 3 hours (i.e., 6 hours from the start).<br/>
        This calculation is performed using GRIB data for each point of the first isochone (where the conditions are now different).<br/>
        This gives us 36 &times; 36 = 1,296 points.<br/>
        We continue in this way until we reach the destination.<br/>
        The number of points to manage quickly becomes very large (even excessive); it's exponential!<br/>
        At the third isochrone, we have 36 &times; 36 &times; 36 = 46,656 points, and 1,679,616 at the fourth! And so on...<br/>
        This can crash any computer — no matter how powerful — before it reaches its destination.<br/>
        Therefore, it's necessary to reduce the number of points on each isochrone.<br/>
        An efficient method is to use the convex hull of the points.<br/>
        The convex hull is the smallest convex polygon that contains all the points.<br/><br/>

        <i><b>Intuitively</b></i>, it's like putting a rubber band around the points; the rubber band will stretch to encompass all the points, thus forming the convex hull.<br/>
        By keeping only the points on the convex hull (eliminating those inside the rubber band), we significantly reduce the number of points to manage.

        <div style="text-align: center;">
            <img src="docs/enveloppe.png" title="enveloppe convexe" style="max-width: 40%; border: 1px solid black;"/>
        </div>
        In red, the points of the first isochrone.<br/>
        In yellow and green, those of the second.<br/>
        Only the points on the convex hull (in green) are retained. The yellow ones are eliminated.<br/>
        See below the effects of the method on a real-world routing (feel free to zoom in):
        <div style="text-align: center;">
            <img src="docs/routing.01.png" title="Routing" style="max-width: 80%; border: 1px solid black;"/>
        </div>
        The final result is the optimal path (in blue) between the starting point and the destination.<br/>
        This result can then be exported in various formats for use by navigation software (for example, in GPX format, but this is far from the only available format).<br/>
        <br/>
    </p>
    <p class="screen-only">
        All the screenshots above are from a routing and navigation software developed in Java (among other languages).
        All the source code is available in its <a class="list-link" href="https://github.com/OlivierLD/ROB/tree/master/raspberry-sailor/Swing/WeatherWizard" target="GitHub">GitHub</a> repository.<br/>
        The user manual is <a href="http://www.lediouris.net/donpedro/software/structure/datafiles/manual/WeatherWizardUserManual.2nd.edition.pdf" target="WW">here</a>.
    </p>

</section>

<div id="full-content">
</div>

<hr/>
<address>
    <small>
        &copy; Olivier Le Diouris - 2025<br/>
        <a href="../index.html" target="_top">OlivierLD.github.io</a>
    </small>
</address>
</body>

<script type="text/javascript">

let navTo = (prm) => {
    let url = window.location.href;
    let newUrl = url.split('?')[0] + '?lang=' + prm;
    console.log("New URL: " + newUrl);
    window.location = newUrl;
};

let getQueryParameterByName = (name, url) => {
    if (!url) {
        url = window.location.href;
    }
    name = name.replace(/[\[\]]/g, "\\$&");
    let regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) {
        return null;
    }
    if (!results[2]) {
        return '';
    }
    return decodeURIComponent(results[2].replace(/\+/g, " "));
};

let translate = (lang) => {
    let enContent = document.getElementById('en-content');
    let frContent = document.getElementById('fr-content');

    let fullContent = document.getElementById('full-content');
    if (lang === 'FR') {
        // enContent.style.display = 'none';
        // frContent.style.display = 'block';
        fullContent.innerHTML = frContent.innerHTML;
        frContent.innerHTML = '';  // Required for anchors to work.
        enContent.innerHTML = '';  // Required for anchors to work.
    } else {
        // enContent.style.display = 'block';
        // frContent.style.display = 'none';
        fullContent.innerHTML = enContent.innerHTML;
        enContent.innerHTML = '';  // Required for anchors to work.
        frContent.innerHTML = '';  // Required for anchors to work.
    }
    // The title
    document.getElementsByTagName('title')[0].innerText =
        (lang === 'FR' ? 'GRIBs, polaires, routage' : 'GRIBs, polars, routing');
};

let translateNew = (lang) => {

    let contentName = `version_${lang}.html`;
    let contentPlaceHolder = document.getElementById('full-content');

    let generateFetchMessage = (name, response) => {
        return `Fetching ${name}...<br/> Data Response: ${response.status} - ${response.statusText}<br/><b>En d&eacute;veloppement...<br/>Disponible prochainement.</b>`;
    };
	fetch(contentName)
            .then(response => {  // Warning... the NOT_FOUND error lands here, apparently.
                console.log(`Data Response: ${response.status} - ${response.statusText}`);
				if (response.status !== 200) { // There is a problem...
                    alert('Oops !')
					contentPlaceHolder.innerHTML = generateFetchMessage(contentName, response); // `Fetching ${contentName}...<br/> Data Response: ${response.status} - ${response.statusText}<br/><b>En d&eacute;veloppement...<br/>Disponible prochainement.</b>`;
				} else {
					response.text().then(doc => {
						console.log(`Code data loaded, length: ${doc.length}.`);
                        let node = new DOMParser().parseFromString(doc, "text/html");
                        let content = node.getElementsByTagName("section").item(0).innerHTML; // Assume there is a <section>
                        contentPlaceHolder.innerHTML = content;
					});
				}
            },
            (error, errmess) => {
                console.log("Ooch");
                let message;
                if (errmess) {
                    let mess = JSON.parse(errmess);
                    if (mess.message) {
                        message = mess.message;
                    }
                }
                console.debug("Failed to get code data..." +
                    (error ? (typeof(error) === 'object' ? JSON.stringify(error, null, 2) : error) : ' - ') +
                    ', ' +
                    (message ? message : ' - ')
                );
            });
}

window.onload = () => { // Important: window.onload
    let userLang = getQueryParameterByName('lang');
    if (!userLang) {
        let browserUserLang = navigator.language || navigator.userLanguage;
        console.log("The browser's language is: " + browserUserLang);
        if (browserUserLang) {
            if (browserUserLang.substring(0, 2).toUpperCase() === 'FR') {
                userLang = 'FR';
                console.log("On va parler français")
            } else {
                userLang = 'EN';
                console.log("We'll speak english");
            }
        }
    }
    if (userLang) {
        langToUse = userLang;
        console.log(`Lang to use will be ${langToUse}`);
    }
    if (langToUse !== 'FR') { // Then switch to French, default is EN.
        langToUse = 'EN';
    }
    translate(langToUse);
    // translateNew(langToUse);
};
</script>

</html>
